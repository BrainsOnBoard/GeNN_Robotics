<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BoB robotics: pybind11 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="bob_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BoB robotics
   </div>
   <div id="projectbrief">The Brains on Board robotics library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacepybind11.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pybind11 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>glibc defines I as a macro which breaks things, e.g., boost template names  
<a href="namespacepybind11.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1is__method.html">is_method</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for methods.  <a href="structpybind11_1_1is__method.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1is__operator.html">is_operator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for operators.  <a href="structpybind11_1_1is__operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1is__final.html">is_final</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for classes that cannot be subclassed.  <a href="structpybind11_1_1is__final.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1scope.html">scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for parent scope.  <a href="structpybind11_1_1scope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1doc.html">doc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for documentation.  <a href="structpybind11_1_1doc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1name.html">name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for function names.  <a href="structpybind11_1_1name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1sibling.html">sibling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation indicating that a function is an overload associated with a given "sibling".  <a href="structpybind11_1_1sibling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1base.html">base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation indicating that a class derives from another given type.  <a href="structpybind11_1_1base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1keep__alive.html">keep_alive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep patient alive while nurse lives.  <a href="structpybind11_1_1keep__alive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1multiple__inheritance.html">multiple_inheritance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation indicating that a class is involved in a multiple inheritance relationship.  <a href="structpybind11_1_1multiple__inheritance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1dynamic__attr.html">dynamic_attr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation which enables dynamic attributes, i.e. adds <code>__dict__</code> to a class.  <a href="structpybind11_1_1dynamic__attr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1buffer__protocol.html">buffer_protocol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation which enables the buffer protocol for a type.  <a href="structpybind11_1_1buffer__protocol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1metaclass.html">metaclass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation which requests that a special metaclass is created for a type.  <a href="structpybind11_1_1metaclass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1module__local.html">module_local</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation that marks a class as local to the module:  <a href="structpybind11_1_1module__local.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1arithmetic.html">arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation to mark enums as an arithmetic type.  <a href="structpybind11_1_1arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1prepend.html">prepend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a function for addition at the beginning of the existing overload chain instead of the end.  <a href="structpybind11_1_1prepend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard.html">call_guard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard_3_4.html">call_guard&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard_3_01T_01_4.html">call_guard&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard_3_01T_00_01Ts_8_8_8_01_4.html">call_guard&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1buffer__info.html">buffer_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information record describing a Python buffer object.  <a href="structpybind11_1_1buffer__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1polymorphic__type__hook__base.html">polymorphic_type_hook_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1polymorphic__type__hook__base_3_01itype_00_01detail_1_1enable__if__t_3_01std_1a2eae5d0afc46e0f2c8bff4143842390.html">polymorphic_type_hook_base&lt; itype, detail::enable_if_t&lt; std::is_polymorphic&lt; itype &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1polymorphic__type__hook.html">polymorphic_type_hook</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1arg.html">arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1arg__v.html">arg_v</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1kw__only.html">kw_only</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1pos__only.html">pos_only</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01std_1_1complex_3_01T_01_4_00_01detail_1_1enable__if__t_335bd2dee28f89d65b53a5265f18b54a.html">format_descriptor&lt; std::complex&lt; T &gt;, detail::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1builtin__exception.html">builtin_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ bindings of builtin Python exceptions.  <a href="classpybind11_1_1builtin__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1stop__iteration.html">stop_iteration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1index__error.html">index_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1key__error.html">key_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1value__error.html">value_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1type__error.html">type_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1buffer__error.html">buffer_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1import__error.html">import_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1cast__error.html">cast_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1reference__cast__error.html">reference_cast_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when pybind11::cast or handle::call fail due to a type casting error.  <a href="classpybind11_1_1reference__cast__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor.html">format_descriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01T_00_01detail_1_1enable__if__t_3_01std_1_1is__arithmetic_3_01T_01_4_1_1value_01_4_01_4.html">format_descriptor&lt; T, detail::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1error__scope.html">error_scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper that temporarily clears any Python error state.  <a href="structpybind11_1_1error__scope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1nodelete.html">nodelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy destructor wrapper that can be used to expose classes with a private destructor.  <a href="structpybind11_1_1nodelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1overload__cast.html">overload_cast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1scoped__interpreter.html">scoped_interpreter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1scoped__ostream__redirect.html">scoped_ostream_redirect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1scoped__estream__redirect.html">scoped_estream_redirect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1dtype.html">dtype</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1array.html">array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1array__t.html">array_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01T_00_01detail_1_1enable__if__t_3_01detail_1_1is__pod__sd2aee290da218819650054b8c635a2ec.html">format_descriptor&lt; T, detail::enable_if_t&lt; detail::is_pod_struct&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01char_0fN_0e_4.html">format_descriptor&lt; char[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01std_1_1array_3_01char_00_01N_01_4_01_4.html">format_descriptor&lt; std::array&lt; char, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01T_00_01detail_1_1enable__if__t_3_01std_1_1is__enum_3_01T_01_4_1_1value_01_4_01_4.html">format_descriptor&lt; T, detail::enable_if_t&lt; std::is_enum&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01T_00_01detail_1_1enable__if__t_3_01detail_1_1array__inff53a1b36e372aeab711589cada4b3062.html">format_descriptor&lt; T, detail::enable_if_t&lt; detail::array_info&lt; T &gt;::is_array &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1options.html">options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1cpp__function.html">cpp_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object.  <a href="classpybind11_1_1cpp__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1module__.html">module_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for Python extension modules.  <a href="classpybind11_1_1module__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1class__.html">class_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1enum__.html">enum_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds C++ enumerations and enumeration classes to Python.  <a href="classpybind11_1_1enum__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1exception.html">exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1gil__scoped__acquire.html">gil_scoped_acquire</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1gil__scoped__release.html">gil_scoped_release</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1handle.html">handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1object.html">object</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1error__already__set.html">error_already_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1type.html">type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1iterable.html">iterable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1str.html">str</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1bytes.html">bytes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1none.html">none</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1ellipsis.html">ellipsis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1bool__.html">bool_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1int__.html">int_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1float__.html">float_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1weakref.html">weakref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1slice.html">slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1capsule.html">capsule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1tuple.html">tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1dict.html">dict</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1sequence.html">sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1list.html">list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1args.html">args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1kwargs.html">kwargs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1set.html">set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1function.html">function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1staticmethod.html">staticmethod</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1buffer.html">buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1memoryview.html">memoryview</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1polymorphic__type__hook_3_01itype_00_01detail_1_1enable__if__t_3_01std_1_1is__ede351517968b3a3b6566f6ef10d55b6.html">polymorphic_type_hook&lt; itype, detail::enable_if_t&lt; std::is_base_of&lt; Animal, itype &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="memTemplParams" colspan="2"><a id="aa14f653ec1b63f58b3013ef9d6ac9422"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#aa14f653ec1b63f58b3013ef9d6ac9422">arg_t</a> = <a class="el" href="structpybind11_1_1arg__v.html">arg_v</a></td></tr>
<tr class="memdesc:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for backward compatibility &ndash; to be removed in version 2.0. <br /></td></tr>
<tr class="separator:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e3d317b399f8925c3b9f1980018481"><td class="memItemLeft" align="right" valign="top"><a id="a51e3d317b399f8925c3b9f1980018481"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ssize_t</b> = Py_ssize_t</td></tr>
<tr class="separator:a51e3d317b399f8925c3b9f1980018481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74292751b6fc8fe14d7c6772ae2fd0fc"><td class="memItemLeft" align="right" valign="top"><a id="a74292751b6fc8fe14d7c6772ae2fd0fc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_t</b> = std::size_t</td></tr>
<tr class="separator:a74292751b6fc8fe14d7c6772ae2fd0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1dc06329bd734b9632f108e2006e25"><td class="memItemLeft" align="right" valign="top"><a id="a9c1dc06329bd734b9632f108e2006e25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EigenDStride</b> = Eigen::Stride&lt; Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a9c1dc06329bd734b9632f108e2006e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23484f7bb5fa23363d338c66c71dc6a8"><td class="memTemplParams" colspan="2"><a id="a23484f7bb5fa23363d338c66c71dc6a8"></a>
template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a23484f7bb5fa23363d338c66c71dc6a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenDRef</b> = Eigen::Ref&lt; MatrixType, 0, EigenDStride &gt;</td></tr>
<tr class="separator:a23484f7bb5fa23363d338c66c71dc6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f353deb5dca5ef06dd63358f9a9bb20"><td class="memTemplParams" colspan="2"><a id="a6f353deb5dca5ef06dd63358f9a9bb20"></a>
template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a6f353deb5dca5ef06dd63358f9a9bb20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenDMap</b> = Eigen::Map&lt; MatrixType, 0, EigenDStride &gt;</td></tr>
<tr class="separator:a6f353deb5dca5ef06dd63358f9a9bb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad952f3f47afb586cdc0f250f70f0a565"><td class="memItemLeft" align="right" valign="top"><a id="ad952f3f47afb586cdc0f250f70f0a565"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>module</b> = <a class="el" href="classpybind11_1_1module__.html">module_</a></td></tr>
<tr class="separator:ad952f3f47afb586cdc0f250f70f0a565"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5f83e7a05cee9068927633ac47dbe69c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca2bd9c0ed00116be1258e0cc66617d7c8">automatic</a> = 0
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca1c1628c22d69b3b9bac4b5c3674852e3">automatic_reference</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca5dc4bb19391b04351f49572019c628c0">take_ownership</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca12cba3ee81cf4a793796a51b6327c678">copy</a>
, <br />
&#160;&#160;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca3734a903022249b3010be1897042568e">move</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">reference</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69caa39bc0596cb125c1605a78fbd287df7f">reference_internal</a>
<br />
 }</td></tr>
<tr class="memdesc:a5f83e7a05cee9068927633ac47dbe69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approach used to cast a previously unknown C++ instance into a Python object.  <a href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">More...</a><br /></td></tr>
<tr class="separator:a5f83e7a05cee9068927633ac47dbe69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a5898f9a083026531bc5d435f715ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715ea">eval_mode</a> { <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715eaa86e05cca1e5516b3ff4014f9af34aaff">eval_expr</a>
, <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715eaa9cf39a293befe652b5046b1e7cf9fe58">eval_single_statement</a>
, <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715eaa22b140993f208620cf25bba6e0d5590b">eval_statements</a>
 }</td></tr>
<tr class="separator:a08a5898f9a083026531bc5d435f715ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ade1f8946c805279f41d7f6eed0d4f07d"><td class="memTemplParams" colspan="2"><a id="ade1f8946c805279f41d7f6eed0d4f07d"></a>
template&lt;typename T , detail::enable_if_t&lt;!detail::is_pyobject&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ade1f8946c805279f41d7f6eed0d4f07d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> (const <a class="el" href="classpybind11_1_1handle.html">handle</a> &amp;<a class="el" href="classpybind11_1_1handle.html">handle</a>)</td></tr>
<tr class="separator:ade1f8946c805279f41d7f6eed0d4f07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999fd9c72081111a7dbe943398f6d42f"><td class="memTemplParams" colspan="2"><a id="a999fd9c72081111a7dbe943398f6d42f"></a>
template&lt;typename T , detail::enable_if_t&lt;!detail::is_pyobject&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a999fd9c72081111a7dbe943398f6d42f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> (T &amp;&amp;value, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> policy=<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca1c1628c22d69b3b9bac4b5c3674852e3">return_value_policy::automatic_reference</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> parent=<a class="el" href="classpybind11_1_1handle.html">handle</a>())</td></tr>
<tr class="separator:a999fd9c72081111a7dbe943398f6d42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cadb7f665dad17868aa4cd045f3b017"><td class="memTemplParams" colspan="2"><a id="a3cadb7f665dad17868aa4cd045f3b017"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3cadb7f665dad17868aa4cd045f3b017"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt;!<a class="el" href="structpybind11_1_1detail_1_1negation.html">detail::move_never</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move</b> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;obj)</td></tr>
<tr class="separator:a3cadb7f665dad17868aa4cd045f3b017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9d391ba89e4dbc85bc088c637a454b"><td class="memTemplParams" colspan="2"><a id="adb9d391ba89e4dbc85bc088c637a454b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb9d391ba89e4dbc85bc088c637a454b"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt; <a class="el" href="structpybind11_1_1detail_1_1move__always.html">detail::move_always</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;<a class="el" href="classpybind11_1_1object.html">object</a>)</td></tr>
<tr class="separator:adb9d391ba89e4dbc85bc088c637a454b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c29751349cfc3a1b5e8b4765c23e55"><td class="memTemplParams" colspan="2"><a id="a37c29751349cfc3a1b5e8b4765c23e55"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37c29751349cfc3a1b5e8b4765c23e55"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt; <a class="el" href="structpybind11_1_1detail_1_1move__if__unreferenced.html">detail::move_if_unreferenced</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;<a class="el" href="classpybind11_1_1object.html">object</a>)</td></tr>
<tr class="separator:a37c29751349cfc3a1b5e8b4765c23e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d1d141b22c8733a7212bc74d89cbf8"><td class="memTemplParams" colspan="2"><a id="a23d1d141b22c8733a7212bc74d89cbf8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23d1d141b22c8733a7212bc74d89cbf8"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt; <a class="el" href="structpybind11_1_1detail_1_1negation.html">detail::move_never</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;<a class="el" href="classpybind11_1_1object.html">object</a>)</td></tr>
<tr class="separator:a23d1d141b22c8733a7212bc74d89cbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e52b4af2513beedc58c660691d96c7"><td class="memTemplParams" colspan="2"><a id="a29e52b4af2513beedc58c660691d96c7"></a>
template&lt;return_value_policy policy = return_value_policy::automatic_reference&gt; </td></tr>
<tr class="memitem:a29e52b4af2513beedc58c660691d96c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1tuple.html">tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_tuple</b> ()</td></tr>
<tr class="separator:a29e52b4af2513beedc58c660691d96c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829aea796e8a24212b310db43534c1b7"><td class="memTemplParams" colspan="2"><a id="a829aea796e8a24212b310db43534c1b7"></a>
template&lt;return_value_policy policy = return_value_policy::automatic_reference, typename... Args&gt; </td></tr>
<tr class="memitem:a829aea796e8a24212b310db43534c1b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1tuple.html">tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_tuple</b> (Args &amp;&amp;... args_)</td></tr>
<tr class="separator:a829aea796e8a24212b310db43534c1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46240bdb807f80caa6e104591878d5c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpybind11_1_1arg.html">arg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ad46240bdb807f80caa6e104591878d5c">operator&quot;&quot;_a</a> (const char *<a class="el" href="structpybind11_1_1name.html">name</a>, size_t)</td></tr>
<tr class="separator:ad46240bdb807f80caa6e104591878d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878f069e172da3a77d4bcf171f06711f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a878f069e172da3a77d4bcf171f06711f">__attribute__</a> ((noinline)) inline void pybind11_fail(const char *reason)</td></tr>
<tr class="memdesc:a878f069e172da3a77d4bcf171f06711f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally.  <a href="namespacepybind11.html#a878f069e172da3a77d4bcf171f06711f">More...</a><br /></td></tr>
<tr class="separator:a878f069e172da3a77d4bcf171f06711f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa297ec4bf4b85dc134d56708fbfcc850"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa297ec4bf4b85dc134d56708fbfcc850"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#aa297ec4bf4b85dc134d56708fbfcc850">get_or_create_shared_data</a> (const std::string &amp;<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:aa297ec4bf4b85dc134d56708fbfcc850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a37202a545a53e60d9722b5712b9171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a4a37202a545a53e60d9722b5712b9171">initialize_interpreter</a> (bool init_signal_handlers=true)</td></tr>
<tr class="separator:a4a37202a545a53e60d9722b5712b9171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f49a19c03be57ee8ff8427a5f30dc20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a2f49a19c03be57ee8ff8427a5f30dc20">finalize_interpreter</a> ()</td></tr>
<tr class="separator:a2f49a19c03be57ee8ff8427a5f30dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26f489829ee95049a3cbf473d3c50bc"><td class="memTemplParams" colspan="2"><a id="ae26f489829ee95049a3cbf473d3c50bc"></a>
template&lt;eval_mode mode = eval_expr&gt; </td></tr>
<tr class="memitem:ae26f489829ee95049a3cbf473d3c50bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eval</b> (<a class="el" href="classpybind11_1_1str.html">str</a> expr, <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:ae26f489829ee95049a3cbf473d3c50bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b1a96dad971e6c0edd9b796cc57880"><td class="memTemplParams" colspan="2"><a id="a56b1a96dad971e6c0edd9b796cc57880"></a>
template&lt;eval_mode mode = eval_expr, size_t N&gt; </td></tr>
<tr class="memitem:a56b1a96dad971e6c0edd9b796cc57880"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eval</b> (const char(&amp;s)[N], <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:a56b1a96dad971e6c0edd9b796cc57880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ca1928aef1b51fa07d8720ce75fdf7"><td class="memItemLeft" align="right" valign="top"><a id="ad3ca1928aef1b51fa07d8720ce75fdf7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>exec</b> (<a class="el" href="classpybind11_1_1str.html">str</a> expr, <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:ad3ca1928aef1b51fa07d8720ce75fdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38838be20e46edfdb3dbc03f176d7bc"><td class="memTemplParams" colspan="2"><a id="ae38838be20e46edfdb3dbc03f176d7bc"></a>
template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ae38838be20e46edfdb3dbc03f176d7bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exec</b> (const char(&amp;s)[N], <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:ae38838be20e46edfdb3dbc03f176d7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3958ed51fe6e4bf962b04e32d01c242"><td class="memTemplParams" colspan="2"><a id="ab3958ed51fe6e4bf962b04e32d01c242"></a>
template&lt;eval_mode mode = eval_statements&gt; </td></tr>
<tr class="memitem:ab3958ed51fe6e4bf962b04e32d01c242"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eval_file</b> (<a class="el" href="classpybind11_1_1str.html">str</a> fname, <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:ab3958ed51fe6e4bf962b04e32d01c242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c945c5879938b28d274b7ad7a74207"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt; <a class="el" href="classpybind11_1_1detail_1_1OstreamRedirect.html">detail::OstreamRedirect</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a93c945c5879938b28d274b7ad7a74207">add_ostream_redirect</a> (<a class="el" href="classpybind11_1_1module__.html">module_</a> m, std::string <a class="el" href="structpybind11_1_1name.html">name</a>=&quot;ostream_redirect&quot;)</td></tr>
<tr class="separator:a93c945c5879938b28d274b7ad7a74207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccb3d918a6c83f0ed93b7aae5e3dd77"><td class="memTemplParams" colspan="2"><a id="a4ccb3d918a6c83f0ed93b7aae5e3dd77"></a>
template&lt;typename Return , typename... Args&gt; </td></tr>
<tr class="memitem:a4ccb3d918a6c83f0ed93b7aae5e3dd77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpybind11_1_1detail_1_1vectorize__helper.html">detail::vectorize_helper</a>&lt; Return(*)(Args...), Return, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorize</b> (Return(*f)(Args ...))</td></tr>
<tr class="separator:a4ccb3d918a6c83f0ed93b7aae5e3dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7db768db7442da913dd254198f0a7dc"><td class="memTemplParams" colspan="2"><a id="ac7db768db7442da913dd254198f0a7dc"></a>
template&lt;typename Func , detail::enable_if_t&lt; detail::is_lambda&lt; Func &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac7db768db7442da913dd254198f0a7dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorize</b> (Func &amp;&amp;f) -&gt; decltype(detail::vectorize_extractor(std::forward&lt; Func &gt;(f),(detail::function_signature_t&lt; Func &gt; *) nullptr))</td></tr>
<tr class="separator:ac7db768db7442da913dd254198f0a7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb3c0b9044e0b0d3e8fc0324f485acf"><td class="memTemplParams" colspan="2"><a id="a1cb3c0b9044e0b0d3e8fc0324f485acf"></a>
template&lt;typename Return , typename Class , typename... Args, typename Helper  = detail::vectorize_helper&lt;decltype(std::mem_fn(std::declval&lt;Return (Class::*)(Args...)&gt;())), Return, Class *, Args...&gt;&gt; </td></tr>
<tr class="memitem:a1cb3c0b9044e0b0d3e8fc0324f485acf"><td class="memTemplItemLeft" align="right" valign="top">Helper&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorize</b> (Return(Class::*f)(Args...))</td></tr>
<tr class="separator:a1cb3c0b9044e0b0d3e8fc0324f485acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4397f2663d6784bd53630fc5a23c02a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1dict.html">dict</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a> ()</td></tr>
<tr class="separator:gaf4397f2663d6784bd53630fc5a23c02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80923cbfeaa7668191f479b40a94957e"><td class="memTemplParams" colspan="2">template&lt;typename , typename F &gt; </td></tr>
<tr class="memitem:a80923cbfeaa7668191f479b40a94957e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a80923cbfeaa7668191f479b40a94957e">method_adaptor</a> (F &amp;&amp;f) -&gt; decltype(std::forward&lt; F &gt;(f))</td></tr>
<tr class="separator:a80923cbfeaa7668191f479b40a94957e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb36fd4bbf6d949769e083dc9bdf7426"><td class="memTemplParams" colspan="2"><a id="aeb36fd4bbf6d949769e083dc9bdf7426"></a>
template&lt;typename Derived , typename Return , typename Class , typename... Args&gt; </td></tr>
<tr class="memitem:aeb36fd4bbf6d949769e083dc9bdf7426"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>method_adaptor</b> (Return(Class::*pmf)(Args...)) -&gt; Return(Derived::*)(Args...)</td></tr>
<tr class="separator:aeb36fd4bbf6d949769e083dc9bdf7426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2e8c8ad54ac9046514e21d5efd1271"><td class="memTemplParams" colspan="2"><a id="aaa2e8c8ad54ac9046514e21d5efd1271"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aaa2e8c8ad54ac9046514e21d5efd1271"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpybind11_1_1detail_1_1initimpl_1_1constructor.html">detail::initimpl::constructor</a>&lt; Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#aaa2e8c8ad54ac9046514e21d5efd1271">init</a> ()</td></tr>
<tr class="memdesc:aaa2e8c8ad54ac9046514e21d5efd1271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an existing constructor taking arguments Args... <br /></td></tr>
<tr class="separator:aaa2e8c8ad54ac9046514e21d5efd1271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4440c3f57bc3167995cc8b59362a72"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aeb4440c3f57bc3167995cc8b59362a72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpybind11_1_1detail_1_1initimpl_1_1alias__constructor.html">detail::initimpl::alias_constructor</a>&lt; Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#aeb4440c3f57bc3167995cc8b59362a72">init_alias</a> ()</td></tr>
<tr class="separator:aeb4440c3f57bc3167995cc8b59362a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72b540437b1862d453598570dfe93d6"><td class="memTemplParams" colspan="2"><a id="aa72b540437b1862d453598570dfe93d6"></a>
template&lt;typename Func , typename Ret  = detail::initimpl::factory&lt;Func&gt;&gt; </td></tr>
<tr class="memitem:aa72b540437b1862d453598570dfe93d6"><td class="memTemplItemLeft" align="right" valign="top">Ret&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#aa72b540437b1862d453598570dfe93d6">init</a> (Func &amp;&amp;f)</td></tr>
<tr class="memdesc:aa72b540437b1862d453598570dfe93d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a factory function as a constructor. <br /></td></tr>
<tr class="separator:aa72b540437b1862d453598570dfe93d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d4d82f9a77e15999d0d7698252465d"><td class="memTemplParams" colspan="2">template&lt;typename CFunc , typename AFunc , typename Ret  = detail::initimpl::factory&lt;CFunc, AFunc&gt;&gt; </td></tr>
<tr class="memitem:af1d4d82f9a77e15999d0d7698252465d"><td class="memTemplItemLeft" align="right" valign="top">Ret&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#af1d4d82f9a77e15999d0d7698252465d">init</a> (CFunc &amp;&amp;c, AFunc &amp;&amp;a)</td></tr>
<tr class="separator:af1d4d82f9a77e15999d0d7698252465d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5210adfdb1ff315690faeb2736386de3"><td class="memTemplParams" colspan="2">template&lt;typename GetState , typename SetState &gt; </td></tr>
<tr class="memitem:a5210adfdb1ff315690faeb2736386de3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpybind11_1_1detail_1_1initimpl_1_1pickle__factory.html">detail::initimpl::pickle_factory</a>&lt; GetState, SetState &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a5210adfdb1ff315690faeb2736386de3">pickle</a> (GetState &amp;&amp;g, SetState &amp;&amp;s)</td></tr>
<tr class="separator:a5210adfdb1ff315690faeb2736386de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97330a2a87d0653768770751b057c5e"><td class="memTemplParams" colspan="2"><a id="ac97330a2a87d0653768770751b057c5e"></a>
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename ValueType  = decltype(*std::declval&lt;Iterator&gt;()), typename... Extra&gt; </td></tr>
<tr class="memitem:ac97330a2a87d0653768770751b057c5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ac97330a2a87d0653768770751b057c5e">make_iterator</a> (Iterator first, Sentinel last, Extra &amp;&amp;... extra)</td></tr>
<tr class="memdesc:ac97330a2a87d0653768770751b057c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a python iterator from a first and past-the-end C++ InputIterator. <br /></td></tr>
<tr class="separator:ac97330a2a87d0653768770751b057c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9720b33862b4fbd9345c2bf2a0e407f7"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename KeyType  = decltype((*std::declval&lt;Iterator&gt;()).first), typename... Extra&gt; </td></tr>
<tr class="memitem:a9720b33862b4fbd9345c2bf2a0e407f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a9720b33862b4fbd9345c2bf2a0e407f7">make_key_iterator</a> (Iterator first, Sentinel last, Extra &amp;&amp;... extra)</td></tr>
<tr class="separator:a9720b33862b4fbd9345c2bf2a0e407f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7e251f8927c3f839ec9beff8662a4c"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </td></tr>
<tr class="memitem:abc7e251f8927c3f839ec9beff8662a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#abc7e251f8927c3f839ec9beff8662a4c">make_iterator</a> (Type &amp;value, Extra &amp;&amp;... extra)</td></tr>
<tr class="separator:abc7e251f8927c3f839ec9beff8662a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451a8f82d09d763f5400dead333116ee"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </td></tr>
<tr class="memitem:a451a8f82d09d763f5400dead333116ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a451a8f82d09d763f5400dead333116ee">make_key_iterator</a> (Type &amp;value, Extra &amp;&amp;... extra)</td></tr>
<tr class="separator:a451a8f82d09d763f5400dead333116ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d4074b855542774c3fbdd75697d48c"><td class="memTemplParams" colspan="2"><a id="aa3d4074b855542774c3fbdd75697d48c"></a>
template&lt;typename InputType , typename OutputType &gt; </td></tr>
<tr class="memitem:aa3d4074b855542774c3fbdd75697d48c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>implicitly_convertible</b> ()</td></tr>
<tr class="separator:aa3d4074b855542774c3fbdd75697d48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4353c0dbefd359b04ebef9e47a0eb359"><td class="memTemplParams" colspan="2"><a id="a4353c0dbefd359b04ebef9e47a0eb359"></a>
template&lt;typename ExceptionTranslator &gt; </td></tr>
<tr class="memitem:a4353c0dbefd359b04ebef9e47a0eb359"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>register_exception_translator</b> (ExceptionTranslator &amp;&amp;translator)</td></tr>
<tr class="separator:a4353c0dbefd359b04ebef9e47a0eb359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465bb0865488c320442f9bbcb505bbb3"><td class="memTemplParams" colspan="2">template&lt;typename CppException &gt; </td></tr>
<tr class="memitem:a465bb0865488c320442f9bbcb505bbb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1exception.html">exception</a>&lt; CppException &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a465bb0865488c320442f9bbcb505bbb3">register_exception</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1scope.html">scope</a>, const char *<a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1base.html">base</a>=PyExc_Exception)</td></tr>
<tr class="separator:a465bb0865488c320442f9bbcb505bbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913a30079a57934b1bfda83ba4080da4"><td class="memTemplParams" colspan="2"><a id="a913a30079a57934b1bfda83ba4080da4"></a>
template&lt;return_value_policy policy = return_value_policy::automatic_reference, typename... Args&gt; </td></tr>
<tr class="memitem:a913a30079a57934b1bfda83ba4080da4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print</b> (Args &amp;&amp;...<a class="el" href="classpybind11_1_1args.html">args</a>)</td></tr>
<tr class="separator:a913a30079a57934b1bfda83ba4080da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df2db054670958a2f7ee92947d4c105"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6df2db054670958a2f7ee92947d4c105"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1function.html">function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a6df2db054670958a2f7ee92947d4c105">get_override</a> (const T *this_ptr, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:a6df2db054670958a2f7ee92947d4c105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d891f9c3ddd91e6dd456514e133c924"><td class="memItemLeft" align="right" valign="top"><a id="a8d891f9c3ddd91e6dd456514e133c924"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((deprecated(&quot;get_type_overload has been deprecated&quot;))) inline <a class="el" href="classpybind11_1_1function.html">function</a> get_type_overload(const void *this_ptr</td></tr>
<tr class="separator:a8d891f9c3ddd91e6dd456514e133c924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf1986e4cc6b7770ee71b3ce88a1a7c"><td class="memTemplParams" colspan="2"><a id="a1bf1986e4cc6b7770ee71b3ce88a1a7c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1bf1986e4cc6b7770ee71b3ce88a1a7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1function.html">function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_overload</b> (const T *this_ptr, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:a1bf1986e4cc6b7770ee71b3ce88a1a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad75b61738e777489ed1f4a30776268"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acad75b61738e777489ed1f4a30776268"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#acad75b61738e777489ed1f4a30776268">reinterpret_borrow</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:acad75b61738e777489ed1f4a30776268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8f2939859acb062ae3c38c8b82b9f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b8f2939859acb062ae3c38c8b82b9f0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a4b8f2939859acb062ae3c38c8b82b9f0">reinterpret_steal</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:a4b8f2939859acb062ae3c38c8b82b9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de041115880fe435885b9a9d7c2c276"><td class="memTemplParams" colspan="2">template&lt;typename T , detail::enable_if_t&lt; std::is_base_of&lt; object, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga2de041115880fe435885b9a9d7c2c276"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga2de041115880fe435885b9a9d7c2c276">isinstance</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)</td></tr>
<tr class="separator:ga2de041115880fe435885b9a9d7c2c276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c89a0add98761af02c3eca6a9b317f2"><td class="memItemLeft" align="right" valign="top"><a id="a3c89a0add98761af02c3eca6a9b317f2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3c89a0add98761af02c3eca6a9b317f2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isinstance&lt; handle &gt;</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a>)=delete</td></tr>
<tr class="separator:a3c89a0add98761af02c3eca6a9b317f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc42dbf138ab0de23a58c7952cb8ba9a"><td class="memItemLeft" align="right" valign="top"><a id="adc42dbf138ab0de23a58c7952cb8ba9a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adc42dbf138ab0de23a58c7952cb8ba9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isinstance&lt; object &gt;</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)</td></tr>
<tr class="separator:adc42dbf138ab0de23a58c7952cb8ba9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514d6552530d0b02362a2045f43fcdba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga514d6552530d0b02362a2045f43fcdba">isinstance</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="classpybind11_1_1type.html">type</a>)</td></tr>
<tr class="separator:ga514d6552530d0b02362a2045f43fcdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87cc23c83cdeaec183f0a0e4122d9997"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:ga87cc23c83cdeaec183f0a0e4122d9997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef7ee96307a4732fad5df956b387f8a8"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:gaef7ee96307a4732fad5df956b387f8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5fa715b1b95c90a87372ea6ad4dc78a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>delattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:gaa5fa715b1b95c90a87372ea6ad4dc78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854c75de22ee024532d54cae1e4dd578"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>delattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:ga854c75de22ee024532d54cae1e4dd578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0854324102907dc2d82ac413b6e6b66e"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:ga0854324102907dc2d82ac413b6e6b66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac80ddad26eb3426c93277ce8d7c0f982"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:gac80ddad26eb3426c93277ce8d7c0f982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga715c20d77757165563f28474dc39e80c"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> default_)</td></tr>
<tr class="separator:ga715c20d77757165563f28474dc39e80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a207d73efa28381746217b7afba118f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> default_)</td></tr>
<tr class="separator:ga7a207d73efa28381746217b7afba118f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d54ac3f3614c110d2ffa5c061ee905"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>setattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> value)</td></tr>
<tr class="separator:gad3d54ac3f3614c110d2ffa5c061ee905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac63dcad9209e4abd96a430bef04414ce"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>setattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> value)</td></tr>
<tr class="separator:gac63dcad9209e4abd96a430bef04414ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ebe43bb70bdbbb9b1f2456ec391429"><td class="memItemLeft" align="right" valign="top">
ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)</td></tr>
<tr class="separator:ga03ebe43bb70bdbbb9b1f2456ec391429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64ce16d2a0ab3f9e80fdde0e0857224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1str.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ac64ce16d2a0ab3f9e80fdde0e0857224">operator&quot;&quot;_s</a> (const char *s, size_t size)</td></tr>
<tr class="separator:ac64ce16d2a0ab3f9e80fdde0e0857224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga443ea89aee29c1a3b9d57324d4d089b6"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga443ea89aee29c1a3b9d57324d4d089b6">len</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="memdesc:ga443ea89aee29c1a3b9d57324d4d089b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a Python object. <br /></td></tr>
<tr class="separator:ga443ea89aee29c1a3b9d57324d4d089b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a0506650aedafad61466d5c933b19e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga20a0506650aedafad61466d5c933b19e">len_hint</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:ga20a0506650aedafad61466d5c933b19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03802ec7d35cdd35a26c59cd53db480"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1str.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>repr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:gad03802ec7d35cdd35a26c59cd53db480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4e8cc0cdd5b04fd00f4ba1f2d0f5b8d"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iter</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)</td></tr>
<tr class="separator:gab4e8cc0cdd5b04fd00f4ba1f2d0f5b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3375b1b2135f6344f5550b7869c5fa64"><td class="memItemLeft" align="right" valign="top"><a id="a3375b1b2135f6344f5550b7869c5fa64"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classpybind11_1_1handle.html">handle</a> &amp;obj)</td></tr>
<tr class="separator:a3375b1b2135f6344f5550b7869c5fa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242d406bd1fa9cf4c8ad5abdd57cbeb7"><td class="memTemplParams" colspan="2"><a id="a242d406bd1fa9cf4c8ad5abdd57cbeb7"></a>
template&lt;typename Vector , typename holder_type  = std::unique_ptr&lt;Vector&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a242d406bd1fa9cf4c8ad5abdd57cbeb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt; Vector, holder_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bind_vector</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1scope.html">scope</a>, std::string const &amp;<a class="el" href="structpybind11_1_1name.html">name</a>, Args &amp;&amp;... <a class="el" href="classpybind11_1_1args.html">args</a>)</td></tr>
<tr class="separator:a242d406bd1fa9cf4c8ad5abdd57cbeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5bfcc3297738852d8db630c90991c7"><td class="memTemplParams" colspan="2"><a id="a0f5bfcc3297738852d8db630c90991c7"></a>
template&lt;typename Map , typename holder_type  = std::unique_ptr&lt;Map&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a0f5bfcc3297738852d8db630c90991c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt; Map, holder_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bind_map</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1scope.html">scope</a>, const std::string &amp;<a class="el" href="structpybind11_1_1name.html">name</a>, Args &amp;&amp;... <a class="el" href="classpybind11_1_1args.html">args</a>)</td></tr>
<tr class="separator:a0f5bfcc3297738852d8db630c90991c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7afff4b33ed1587b44716947e6260020"><td class="memItemLeft" align="right" valign="top"><a id="a7afff4b33ed1587b44716947e6260020"></a>
const <a class="el" href="structpybind11_1_1detail_1_1type__info.html">detail::type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>this_type</b></td></tr>
<tr class="separator:a7afff4b33ed1587b44716947e6260020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6c7ea3a45d3dc0689f9cde5013933f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpybind11_1_1detail_1_1type__info.html">detail::type_info</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:a6e6c7ea3a45d3dc0689f9cde5013933f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>glibc defines I as a macro which breaks things, e.g., boost template names </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a08a5898f9a083026531bc5d435f715ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a5898f9a083026531bc5d435f715ea">&#9670;&nbsp;</a></span>eval_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715ea">pybind11::eval_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a08a5898f9a083026531bc5d435f715eaa86e05cca1e5516b3ff4014f9af34aaff"></a>eval_expr&#160;</td><td class="fielddoc"><p>Evaluate a string containing an isolated expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08a5898f9a083026531bc5d435f715eaa9cf39a293befe652b5046b1e7cf9fe58"></a>eval_single_statement&#160;</td><td class="fielddoc"><p>Evaluate a string containing a single statement. Returns <code>none</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08a5898f9a083026531bc5d435f715eaa22b140993f208620cf25bba6e0d5590b"></a>eval_statements&#160;</td><td class="fielddoc"><p>Evaluate a string containing a sequence of statement. Returns <code>none</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5f83e7a05cee9068927633ac47dbe69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f83e7a05cee9068927633ac47dbe69c">&#9670;&nbsp;</a></span>return_value_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">pybind11::return_value_policy</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approach used to cast a previously unknown C++ instance into a Python object. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca2bd9c0ed00116be1258e0cc66617d7c8"></a>automatic&#160;</td><td class="fielddoc"><p>This is the default return value policy, which falls back to the policy <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca5dc4bb19391b04351f49572019c628c0">return_value_policy::take_ownership</a> when the return value is a pointer. Otherwise, it uses return_value::move or return_value::copy for rvalue and lvalue references, respectively. See below for a description of what all of these different policies do. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca1c1628c22d69b3b9bac4b5c3674852e3"></a>automatic_reference&#160;</td><td class="fielddoc"><p>As above, but use policy <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">return_value_policy::reference</a> when the return value is a pointer. This is the default conversion policy for function arguments when calling Python functions manually from C++ code (i.e. via handle::operator()). You probably won't need to use this. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca5dc4bb19391b04351f49572019c628c0"></a>take_ownership&#160;</td><td class="fielddoc"><p>Reference an existing object (i.e. do not create a new copy) and take ownership. Python will call the destructor and delete operator when the object’s reference count reaches zero. Undefined behavior ensues when the C++ side does the same.. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca12cba3ee81cf4a793796a51b6327c678"></a>copy&#160;</td><td class="fielddoc"><p>Create a new copy of the returned object, which will be owned by Python. This policy is comparably safe because the lifetimes of the two instances are decoupled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca3734a903022249b3010be1897042568e"></a>move&#160;</td><td class="fielddoc"><p>Use std::move to move the return value contents into a new instance that will be owned by Python. This policy is comparably safe because the lifetimes of the two instances (move source and destination) are decoupled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22"></a>reference&#160;</td><td class="fielddoc"><p>Reference an existing object, but do not take ownership. The C++ side is responsible for managing the object’s lifetime and deallocating it when it is no longer used. Warning: undefined behavior will ensue when the C++ side deletes an object that is still referenced and used by Python. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69caa39bc0596cb125c1605a78fbd287df7f"></a>reference_internal&#160;</td><td class="fielddoc"><p>This policy only applies to methods and properties. It references the object without taking ownership similar to the above <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">return_value_policy::reference</a> policy. In contrast to that policy, the function or property’s implicit this argument (called the parent) is considered to be the the owner of the return value (the child). <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> then couples the lifetime of the parent to the child via a reference relationship that ensures that the parent cannot be garbage collected while Python is still using the child. More advanced variations of this scheme are also possible using combinations of <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">return_value_policy::reference</a> and the <a class="el" href="structpybind11_1_1keep__alive.html" title="Keep patient alive while nurse lives.">keep_alive</a> call policy </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a878f069e172da3a77d4bcf171f06711f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878f069e172da3a77d4bcf171f06711f">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pybind11::__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(noinline)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally. </p>
<p>Set the shared data that can be later recovered by <code>get_shared_data()</code>.</p>
<p>Returns a named pointer that is shared among all extension modules (using the same <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> version) running in the current interpreter. Names starting with underscores are reserved for internal usage. Returns <code>nullptr</code> if no matching entry was found. </p>

</div>
</div>
<a id="a93c945c5879938b28d274b7ad7a74207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c945c5879938b28d274b7ad7a74207">&#9670;&nbsp;</a></span>add_ostream_redirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt;<a class="el" href="classpybind11_1_1detail_1_1OstreamRedirect.html">detail::OstreamRedirect</a>&gt; pybind11::add_ostream_redirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1module__.html">module_</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ostream_redirect&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\rst This is a helper function to add a C++ redirect context manager to Python instead of using a C++ guard. To use it, add the following to your binding code:</p>
<p>.. code-block:: cpp </p><pre class="fragment">#include &lt;pybind11/iostream.h&gt;

...

py::add_ostream_redirect(m, "ostream_redirect");
</pre><p> You now have a Python context manager that redirects your output:</p>
<p>.. code-block:: python </p><pre class="fragment">with m.ostream_redirect():
    m.print_to_cout_function()
</pre><p> This manager can optionally be told which streams to operate on:</p>
<p>.. code-block:: python </p><pre class="fragment">with m.ostream_redirect(stdout=true, stderr=true):
    m.noisy_function_with_error_printing()
</pre><p> \endrst </p>

</div>
</div>
<a id="a2f49a19c03be57ee8ff8427a5f30dc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f49a19c03be57ee8ff8427a5f30dc20">&#9670;&nbsp;</a></span>finalize_interpreter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::finalize_interpreter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\rst Shut down the Python interpreter. No <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> or CPython API functions can be called after this. In addition, <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> objects must not outlive the interpreter:</p>
<p>.. code-block:: cpp </p><pre class="fragment">{ // BAD
    py::initialize_interpreter();
    auto hello = py::str("Hello, World!");
    py::finalize_interpreter();
} // &lt;-- BOOM, hello's destructor is called after interpreter shutdown

{ // GOOD
    py::initialize_interpreter();
    { // scoped
        auto hello = py::str("Hello, World!");
    } // &lt;-- OK, hello is cleaned up properly
    py::finalize_interpreter();
}

{ // BETTER
    py::scoped_interpreter guard{};
    auto hello = py::str("Hello, World!");
}
</pre><p> .. warning:: </p><pre class="fragment">The interpreter can be restarted by calling `initialize_interpreter` again.
Modules created using pybind11 can be safely re-initialized. However, Python
itself cannot completely unload binary extension modules and there are several
caveats with regard to interpreter restarting. All the details can be found
in the CPython documentation. In short, not all interpreter memory may be
freed, either due to reference cycles or user-created global data.
</pre><p> \endrst </p>

</div>
</div>
<a id="aa297ec4bf4b85dc134d56708fbfcc850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa297ec4bf4b85dc134d56708fbfcc850">&#9670;&nbsp;</a></span>get_or_create_shared_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; pybind11::get_or_create_shared_data </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a typed reference to a shared data entry (by using <code>get_shared_data()</code>) if such entry exists. Otherwise, a new object of default-constructible type <code>T</code> is added to the shared data under the given name and a reference to it is returned. </p>

</div>
</div>
<a id="a6df2db054670958a2f7ee92947d4c105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df2db054670958a2f7ee92947d4c105">&#9670;&nbsp;</a></span>get_override()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1function.html">function</a> pybind11::get_override </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>this_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\rst Try to retrieve a python method by the provided name from the instance pointed to by the this_ptr.</p>
<p>:this_ptr: The pointer to the object the overriden method should be retrieved for. This should be the first non-trampoline class encountered in the inheritance chain. :name: The name of the overridden Python method to retrieve. :return: The Python method by this name from the object or an empty function wrapper. \endrst </p>

</div>
</div>
<a id="af1d4d82f9a77e15999d0d7698252465d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d4d82f9a77e15999d0d7698252465d">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CFunc , typename AFunc , typename Ret  = detail::initimpl::factory&lt;CFunc, AFunc&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ret pybind11::init </td>
          <td>(</td>
          <td class="paramtype">CFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dual-argument factory function: the first function is called when no alias is needed, the second when an alias is needed (i.e. due to python-side inheritance). Arguments must be identical. </p>

</div>
</div>
<a id="aeb4440c3f57bc3167995cc8b59362a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4440c3f57bc3167995cc8b59362a72">&#9670;&nbsp;</a></span>init_alias()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpybind11_1_1detail_1_1initimpl_1_1alias__constructor.html">detail::initimpl::alias_constructor</a>&lt;Args...&gt; pybind11::init_alias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <code>init&lt;Args...&gt;()</code>, but the instance is always constructed through the alias class (even when not inheriting on the Python side). </p>

</div>
</div>
<a id="a4a37202a545a53e60d9722b5712b9171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a37202a545a53e60d9722b5712b9171">&#9670;&nbsp;</a></span>initialize_interpreter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::initialize_interpreter </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_signal_handlers</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\rst Initialize the Python interpreter. No other <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> or CPython API functions can be called before this is done; with the exception of <code>PYBIND11_EMBEDDED_MODULE</code>. The optional parameter can be used to skip the registration of signal handlers (see the <code>Python documentation</code>_ for details). Calling this function again after the interpreter has already been initialized is a fatal error.</p>
<p>If initializing the Python interpreter fails, then the program is terminated. (This is controlled by the CPython runtime and is an exception to <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a>'s normal behavior of throwing exceptions on errors.)</p>
<p>.. _Python documentation: <a href="https://docs.python.org/3/c-api/init.html#c.Py_InitializeEx">https://docs.python.org/3/c-api/init.html#c.Py_InitializeEx</a> \endrst </p>

</div>
</div>
<a id="abc7e251f8927c3f839ec9beff8662a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7e251f8927c3f839ec9beff8662a4c">&#9670;&nbsp;</a></span>make_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_iterator </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an iterator over values of an stl container or other container supporting <code>std::begin()</code>/<code>std::end()</code> </p>

</div>
</div>
<a id="a9720b33862b4fbd9345c2bf2a0e407f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9720b33862b4fbd9345c2bf2a0e407f7">&#9670;&nbsp;</a></span>make_key_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename KeyType  = decltype((*std::declval&lt;Iterator&gt;()).first), typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_key_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an python iterator over the keys (<code>.first</code>) of a iterator over pairs from a first and past-the-end InputIterator. </p>

</div>
</div>
<a id="a451a8f82d09d763f5400dead333116ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451a8f82d09d763f5400dead333116ee">&#9670;&nbsp;</a></span>make_key_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_key_iterator </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an iterator over the keys (<code>.first</code>) of a stl map-like container supporting <code>std::begin()</code>/<code>std::end()</code> </p>

</div>
</div>
<a id="a80923cbfeaa7668191f479b40a94957e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80923cbfeaa7668191f479b40a94957e">&#9670;&nbsp;</a></span>method_adaptor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pybind11::method_adaptor </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; decltype(std::forward&lt;F&gt;(f)) </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a pointer to a member function, cast it to its <code>Derived</code> version. Forward everything else unchanged. </p>

</div>
</div>
<a id="ad46240bdb807f80caa6e104591878d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46240bdb807f80caa6e104591878d5c">&#9670;&nbsp;</a></span>operator&quot;&quot;_a()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpybind11_1_1arg.html">arg</a> pybind11::literals::operator&quot;&quot;_a </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\rst String literal version of <code>arg</code> \endrst </p>

</div>
</div>
<a id="ac64ce16d2a0ab3f9e80fdde0e0857224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64ce16d2a0ab3f9e80fdde0e0857224">&#9670;&nbsp;</a></span>operator&quot;&quot;_s()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1str.html">str</a> pybind11::literals::operator&quot;&quot;_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\rst String literal version of <code>str</code> \endrst </p>

</div>
</div>
<a id="a5210adfdb1ff315690faeb2736386de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5210adfdb1ff315690faeb2736386de3">&#9670;&nbsp;</a></span>pickle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GetState , typename SetState &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpybind11_1_1detail_1_1initimpl_1_1pickle__factory.html">detail::initimpl::pickle_factory</a>&lt;GetState, SetState&gt; pybind11::pickle </td>
          <td>(</td>
          <td class="paramtype">GetState &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SetState &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds pickling functions <code>__getstate__</code> and <code>__setstate__</code> and ensures that the type returned by <code>__getstate__</code> is the same as the argument accepted by <code>__setstate__</code>. </p>

</div>
</div>
<a id="a465bb0865488c320442f9bbcb505bbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465bb0865488c320442f9bbcb505bbb3">&#9670;&nbsp;</a></span>register_exception()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CppException &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1exception.html">exception</a>&lt;CppException&gt;&amp; pybind11::register_exception </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>base</em> = <code>PyExc_Exception</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a Python exception in <code>m</code> of the given <code>name</code> and installs an exception translator to translate the C++ exception to the created Python exception using the exceptions what() method. This is intended for simple exception translations; for more complex translation, register the exception object and translator directly. </p>

</div>
</div>
<a id="acad75b61738e777489ed1f4a30776268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad75b61738e777489ed1f4a30776268">&#9670;&nbsp;</a></span>reinterpret_borrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pybind11::reinterpret_borrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\rst Declare that a <code>handle</code> or <code>PyObject *</code> is a certain type and borrow the reference. The target type <code>T</code> must be <code>object</code> or one of its derived classes. The function doesn't do any conversions or checks. It's up to the user to make sure that the target type is correct.</p>
<p>.. code-block:: cpp </p><pre class="fragment">PyObject *p = PyList_GetItem(obj, index);
py::object o = reinterpret_borrow&lt;py::object&gt;(p);
</pre><p> or py::tuple t = reinterpret_borrow&lt;py::tuple&gt;(p); // &lt;&ndash; <code>p</code> must be already be a <code>tuple</code> \endrst </p>

</div>
</div>
<a id="a4b8f2939859acb062ae3c38c8b82b9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8f2939859acb062ae3c38c8b82b9f0">&#9670;&nbsp;</a></span>reinterpret_steal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pybind11::reinterpret_steal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\rst Like <code>reinterpret_borrow</code>, but steals the reference.</p>
<p>.. code-block:: cpp</p>
<p>PyObject *p = PyObject_Str(obj); py::str s = reinterpret_steal&lt;py::str&gt;(p); // &lt;&ndash; <code>p</code> must be already be a <code>str</code> \endrst </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6e6c7ea3a45d3dc0689f9cde5013933f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6c7ea3a45d3dc0689f9cde5013933f">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpybind11_1_1detail_1_1type__info.html">detail::type_info</a> const char* <a class="el" href="structpybind11_1_1name.html">pybind11::name</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> detail::get_type_override(this_ptr, this_type, name)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepybind11.html">pybind11</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
